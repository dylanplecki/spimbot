SMOOSHED_COUNT: .word 0

# syscall constants
PRINT_STRING	= 4

# spimbot constants
VELOCITY	= 0xffff0010
ANGLE		= 0xffff0014
ANGLE_CONTROL	= 0xffff0018
BOT_X		= 0xffff0020
BOT_Y		= 0xffff0024

BONK_MASK	= 0x1000
BONK_ACK	= 0xffff0060

TIMER		= 0xffff001c
TIMER_MASK	= 0x8000
TIMER_ACK	= 0xffff006c

# fruit constants
FRUIT_SCAN	= 0xffff005c
FRUIT_SMASH	= 0xffff0068

SMOOSHED_MASK	= 0x2000
SMOOSHED_ACK	= 0xffff0064

# could be useful for debugging
PRINT_INT	= 0xffff0080

#FRUIT_SCAN = 0xffff005c


.align 2
fruit_data: .space 260

.text
	# NOTES
	# must use bonk_interrupt
	# once inside bonk_interrupt, you should write to the FRUIT_SMASH mem mapped io
	# FRUIT_SMASH will only work if you are at the bottom of the map and it the interrupt handler
	# SPIMbot is considered to be in the bonk_interrupt when the bonk bit in the Cause register is set to 1. 
	# YOU MUST SMASH ALL FRUITS YOU WANT TO BEFORE ACKNOWLEDGING THE BONK INTERRUPT
	# acknowledging the interrupt will clear the bonk bit in the Cause reg and all writes to FRUIT_SMASH will fail.
	# 
	# make use of the fruit_smooshed interrupt

main:
	li	$t9, BONK_MASK	
	li	$t1, SMOOSHED_MASK
	or	$t9, $t1, $t9
	or	$t9, $t9, 1
	mtc0	$t9, $12
	


	j moveToBottom

moveToBottom:
	lw	$t5, BOT_Y
	
	li	$t1, 90
	sw	$t1, ANGLE

	li	$t2, 1
	sw	$t2, ANGLE_CONTROL

	
	bge	$t5, 290, at_bottom

	j moveToBottom


at_bottom:
	# before moving in any direction, check SMOOSHED_COUNT and smash if there is one in there
	# to smash go 90 degrees and go back when done smashing
	la	$t0, fruit_data
	sw	$t0, FRUIT_SCAN
	
	li	$t5, 1
	lw	$t2, SMOOSHED_COUNT # loads smooshed count
	bge	$t2, $t5, smash		# if smooshed count is >= 1, smash

	lw	$t1, 8($t0) # should set $t1 to the first fruit's x location
	lw	$t9, BOT_X # or la
	# if target x location is greater than BOT_X, bot should go right to smoosh
	# else bot should go left to smoosh
	
	bge	$t9, $t1, botXGreater
	bge	$t1, $t9, botXLess

	j	at_bottom

botXGreater:
	la	$t0, fruit_data
	sw	$t0, FRUIT_SCAN

	lw	$t1, 8($t0) # should set $t1 to the first fruit's x location
	lw	$t9, BOT_X # or la

	li	$t3, 180
	sw	$t3, ANGLE
	
	li	$t4, 1
	sw	$t4, ANGLE_CONTROL

	li	$t5, 10
	sw	$t5, VELOCITY

	ble	$t9, $t1, at_bottom # don't know which break it should be


	j	botXGreater


botXLess:
	la	$t0, fruit_data
	sw	$t0, FRUIT_SCAN

	lw	$t1, 8($t0) # should set $t1 to the first fruit's x location
	lw	$t9, BOT_X # or la

	li	$t3, 0
	sw	$t3, ANGLE
	
	li	$t4, 1
	sw	$t4, ANGLE_CONTROL

	li	$t5, 10
	sw	$t5, VELOCITY


	bge	$t9, $t1, at_bottom



	j botXLess	

smash:
	li	$t9, 90	
	sw	$t9, ANGLE
	
	li	$t1, 1
	sw	$t1, ANGLE_CONTROL
	
	li	$t2, 5
	sw	$t2, VELOCITY

	j	at_bottom


.kdata				# interrupt handler data (separated just for readability)
chunkIH:	.space 8	# space for two registers
non_intrpt_str:	.asciiz "Non-interrupt exception\n"
unhandled_str:	.asciiz "Unhandled interrupt type\n"


.ktext 0x80000180
interrupt_handler:
.set noat
	move	$k1, $at		# Save $at                               
.set at
	la	$k0, chunkIH
	sw	$a0, 0($k0)		# Get some free registers                  
	sw	$a1, 4($k0)		# by storing them to a global variable     

	mfc0	$k0, $13		# Get Cause register                       
	srl	$a0, $k0, 2                
	and	$a0, $a0, 0xf		# ExcCode field                            
	bne	$a0, 0, non_intrpt         

interrupt_dispatch:			# Interrupt:                             
	mfc0	$k0, $13		# Get Cause register, again                 
	beq	$k0, 0, done		# handled all outstanding interrupts     

	and	$a0, $k0, BONK_MASK	# is there a bonk interrupt?                
	bne	$a0, 0, bonk_interrupt   

	and	$a0, $k0, TIMER_MASK	# is there a timer interrupt?
	bne	$a0, 0, timer_interrupt

	and	$a0, $k0, SMOOSHED_MASK # is there a smooshed mask?
	bne	$a0, 0, smooshed_interrupt

	# add dispatch for other interrupt types here.

	li	$v0, PRINT_STRING	# Unhandled interrupt types
	la	$a0, unhandled_str
	syscall 
	j	done

bonk_interrupt:
	li	$t1, 1
	sw	$t1, FRUIT_SMASH		# smashes
	lw	$t9, SMOOSHED_COUNT
	sub	$t9, $t9, 1		# updates smoosh_count
	sw	$t9, SMOOSHED_COUNT
	sw	$a1, BONK_ACK		# acknowledge interrupt
	sw	$zero, VELOCITY		# ???
	
	j	interrupt_dispatch	# see if other interrupts are waiting

timer_interrupt:

smooshed_interrupt:
	li	$t1, 1
	sw	$t1, SMOOSHED_ACK
	lw	$t9, SMOOSHED_COUNT
	add	$t9, $t9, 1
	sw	$t9, SMOOSHED_COUNT

	j	interrupt_dispatch

	
non_intrpt:				# was some non-interrupt
	li	$v0, PRINT_STRING
	la	$a0, non_intrpt_str
	syscall				# print out an error message
	# fall through to done

done:
	la	$k0, chunkIH
	lw	$a0, 0($k0)		# Restore saved registers
	lw	$a1, 4($k0)
.set noat
	move	$at, $k1		# Restore $at
.set at 
	eret
